// cl_radiance /////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "rt_parameters.h"

# define RT_CHOICE_DIFFUSE	0
# define RT_CHOICE_REFLECT	1
# define RT_CHOICE_REFRACT	2

static void					radiance_add(
							constant t_scene *scene,
							global t_camera *camera,
							t_intersection *intersection,
							global RT_F4 *sample,
							constant t_cl_renderer_settings *settings,
							global ulong *rng_state)
{
	RT_F4					radiance;
	RT_F4					light;
	RT_F4					mask;
	RT_F					cosine;
	RT_F					choice_value;
	RT_F					choice_result;

	radiance = (RT_F4){0.f, 0.f, 0.f, 1.f};
	mask = 1;
	for (int depth = 0; depth < settings->sample_depth; depth++)
	{
		if (!scene_intersect(scene, intersection, settings))
			break ;

		if (depth > settings->sample_depth / 2 + 1 && f4_max_component(intersection->material.color) < rng(rng_state))
			break ;

		radiance += mask * intersection->material.emission;

#ifndef RT_OPEN_CL_LIGHT_BASIC_DISABLED
		if (settings->light_basic)
		{
			light = light_basic(scene, intersection, settings, camera->filter_cartoon);
            radiance += light * mask;
		}
#endif

#ifndef RT_OPEN_CL_LIGHT_AREA_DISABLED
		if (settings->light_area)
		{
			light = light_area(scene, intersection, settings, rng_state);
			radiance += light * mask * intersection->material.color;
		}
#endif

		choice_value = rng(rng_state);
		choice_result = RT_CHOICE_DIFFUSE;

		if (intersection->material.reflectance == (RT_F)1. || (intersection->material.reflectance > 0. && choice_value < intersection->material.reflectance))
			choice_result = RT_CHOICE_REFLECT;
		else if (intersection->material.transparence == (RT_F)1. || (intersection->material.transparence > 0. && choice_value < intersection->material.transparence))
			choice_result = RT_CHOICE_REFRACT;

		if (choice_result == RT_CHOICE_REFLECT)
		{
			intersection_reflect(intersection, intersection);
			mask /= intersection->material.reflectance;
			depth--;
		}
		else if (choice_result == RT_CHOICE_REFRACT)
		{
			intersection_refract(intersection, intersection);
			mask /= intersection->material.transparence;
			depth--;
		}
		else if (choice_result == RT_CHOICE_DIFFUSE)
		{
		    intersection->ray.origin = intersection->hit;
            intersection->ray.direction = sample_uniform(&intersection->normal, &cosine, rng_state);
            mask *= intersection->material.color * cosine;
		}
	}

	if (settings->sample_count == 1)
		*sample = radiance;
	else
		*sample += radiance;
}

static RT_F4				radiance_get(
							global RT_F4 *sample,
							constant t_cl_renderer_settings *settings)
{
	return (*sample / settings->sample_count);
}