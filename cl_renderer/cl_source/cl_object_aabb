// cl_object_aabb ////////////////////////////////////////////////////////////////////////////////////////////////////

#include "rt_parameters.h"

typedef struct 				s_object_aabb
{
    RT_F4					min;
    RT_F4					max;
}							t_object_aabb;

static int     				aabb_intersect(constant t_object *object, t_intersection *intersection)
{
	t_object_aabb			data;
	RT_F4					normal;
	RT_F					t_near;
	RT_F					t_far;
	RT_F					t_temp;
	RT_F					inv_dir;
	RT_F					t[2];
	int						i;

    data = *(constant t_object_aabb *)object->data;
	i = 0;
	t_near = -INFINITY;
	t_near = INFINITY;
	while (i < 3)
    {
    	inv_dir = 1. / f4_iter(intersection->ray.direction, i);
    	t[0] = (f4_iter(data.min, i) - f4_iter(intersection->ray.origin, i)) * inv_dir;
    	t[1] = (f4_iter(data.max, i) - f4_iter(intersection->ray.origin, i)) * inv_dir;
    	if (inv_dir < 0.)
    	{
    		t_temp = t[0];
    		t[0] = t[1];
    		t[1] = t_temp;
    	}
    	if ((t_near = RT_MAX(t[0], t_near)) == t[0])
        {
        	normal = (0.);
        	if (i == 0)
        		normal.x = inv_dir < 0. ? 1. : -1.;
        	else if (i == 1)
                normal.y = inv_dir < 0. ? 1. : -1.;
            else if (i == 2)
                normal.z = inv_dir < 0. ? 1. : -1.;
        }
    	//t_near = RT_MAX(t[0], t_near);
    	t_far = RT_MIN(t[1], t_far);
    	if (t_far <= t_near)
    		return (0);
    	i++;
    }
	if (t_near == -INFINITY || t_near >= intersection->ray.t)
    		return (0);
	intersection->ray.t = t_near;
	intersection->object_id = object->id;
    return (1);
}

static RT_F4					aabb_normal(constant t_object *object, t_intersection *intersection)
{
	return (normalize(intersection->hit - ((constant t_object_aabb *)object->data)->min));
}
