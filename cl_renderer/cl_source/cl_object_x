// cl_object_x /////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "rt_control.h"
#include "rt_parameters.h"

static int			object_intersect(constant t_object *object, t_intersection *intersection)
{
	if (object->type == object_sphere)
		return (sphere_intersect(object, intersection));
	else if (object->type == object_plane)
		return (plane_intersect(object, intersection));
	else if (object->type == object_cone)
		return (cone_intersect(object, intersection));
	else if (object->type == object_cylinder)
		return (cylinder_intersect(object, intersection));
	else if (object->type == object_paraboloid)
		return (paraboloid_intersect(object, intersection));
	else if (object->type == object_moebius)
		return (moebius_intersect(object, intersection));
	return (0);
}

static RT_F			object_sdf(constant t_object *object, RT_F4 point)
{
	if (object->is_csg)
		return (RT_INFINITY);
	if (object->type == object_sphere)
		return (sphere_sdf(object, point));
	else if (object->type == object_plane)
		return (plane_sdf(object, point));
	else if (object->type == object_julia)
		return (julia_sdf(object, point));
	else if (object->type == object_mandelbulb)
		return (mandelbulb_sdf(object, point));
	else if (object->type == object_torus)
		return (torus_sdf(object, point));
	else if (object->type == object_box)
		return (box_sdf(object, point));
	else if (object->type == object_csg)
		return (csg_sdf(object, point));
	return (RT_INFINITY);
}

static RT_F			object_center_shift(constant t_object *object)
{
	if (object->type == object_sphere)
		return (sphere_center_shift(object));
	return (0);
}

static RT_F4		object_normal_rm(constant t_object *object, RT_F4 hit)
{
	RT_F4			nudged_hit;
	RT_F4			normal;
	RT_F4			normal_negative;
	RT_F4			nudge;

	nudge = (RT_F4){RT_CL_RM_NORMAL_EPSILON, 0., 0., 0.};
	nudged_hit = hit + nudge;
	normal.x = object_sdf(object, nudged_hit);
	nudged_hit = hit - nudge;
	normal_negative.x = object_sdf(object, nudged_hit);
	normal.x -= normal_negative.x;

	nudge = (RT_F4){0., RT_CL_RM_NORMAL_EPSILON, 0., 0.};
	nudged_hit = hit + nudge;
	normal.y = object_sdf(object, nudged_hit);
	nudged_hit = hit - nudge;
	normal_negative.y = object_sdf(object, nudged_hit);
	normal.y -= normal_negative.y;

	nudge = (RT_F4){0., 0., RT_CL_RM_NORMAL_EPSILON, 0.};
	nudged_hit = hit + nudge;
	normal.z = object_sdf(object, nudged_hit);
	nudged_hit = hit - nudge;
	normal_negative.z = object_sdf(object, nudged_hit);
	normal.z -= normal_negative.z;

    return (normalize(normal));
}

static RT_F4		object_normal_rt(
					constant t_object *object,
                    t_intersection *intersection)
{
	if (object->type == object_sphere)
		return (sphere_normal(object, intersection));
	else if (object->type == object_plane)
		return (plane_normal(object, intersection));
	else if (object->type == object_cone)
	    return (cone_normal(object, intersection));
	else if (object->type == object_cylinder)
	    return (cylinder_normal(object, intersection));
 	return (0);
}

static RT_F4		object_normal(
					constant t_object *object,
					t_intersection *intersection,
					constant t_cl_renderer_settings *settings)
{
#if defined RT_OPEN_CL_RT_ONLY
	return (object_normal_rt(object, intersection));
#elif defined RT_OPEN_CL_RM_ONLY
	return (object_normal_rm(object, intersection->hit));
#else
	return (!settings->rm_mod ?
    		object_normal_rt(object, intersection) :
    		object_normal_rm(object, intersection->hit));
#endif
}